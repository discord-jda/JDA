/*
 * Copyright 2015 Austin Keener, Michael Ritter, Florian Spie√ü, and the JDA contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.dv8tion.jda.api.entities

import net.dv8tion.jda.annotations.ForRemoval
import net.dv8tion.jda.annotations.ReplaceWith
import net.dv8tion.jda.api.JDA
import net.dv8tion.jda.api.entities.Message.MessageFlag
import net.dv8tion.jda.api.entities.channel.ChannelType
import net.dv8tion.jda.api.entities.channel.concrete.*
import net.dv8tion.jda.api.entities.channel.middleman.GuildChannel
import net.dv8tion.jda.api.entities.channel.middleman.GuildMessageChannel
import net.dv8tion.jda.api.entities.channel.middleman.MessageChannel
import net.dv8tion.jda.api.entities.channel.unions.GuildMessageChannelUnion
import net.dv8tion.jda.api.entities.channel.unions.MessageChannelUnion
import net.dv8tion.jda.api.entities.emoji.CustomEmoji
import net.dv8tion.jda.api.entities.emoji.Emoji
import net.dv8tion.jda.api.entities.emoji.RichCustomEmoji
import net.dv8tion.jda.api.entities.sticker.GuildSticker
import net.dv8tion.jda.api.entities.sticker.StickerItem
import net.dv8tion.jda.api.entities.sticker.StickerSnowflake
import net.dv8tion.jda.api.exceptions.HttpException
import net.dv8tion.jda.api.exceptions.InsufficientPermissionException
import net.dv8tion.jda.api.interactions.InteractionType
import net.dv8tion.jda.api.interactions.components.ActionRow
import net.dv8tion.jda.api.interactions.components.LayoutComponent
import net.dv8tion.jda.api.interactions.components.buttons.Button
import net.dv8tion.jda.api.requests.RestAction
import net.dv8tion.jda.api.requests.RestConfig
import net.dv8tion.jda.api.requests.restaction.AuditableRestAction
import net.dv8tion.jda.api.requests.restaction.MessageCreateAction
import net.dv8tion.jda.api.requests.restaction.MessageEditAction
import net.dv8tion.jda.api.requests.restaction.ThreadChannelAction
import net.dv8tion.jda.api.requests.restaction.pagination.ReactionPaginationAction
import net.dv8tion.jda.api.utils.AttachedFile
import net.dv8tion.jda.api.utils.AttachmentProxy
import net.dv8tion.jda.api.utils.FileUpload
import net.dv8tion.jda.api.utils.data.DataObject
import net.dv8tion.jda.api.utils.messages.MessageCreateData
import net.dv8tion.jda.api.utils.messages.MessageEditData
import net.dv8tion.jda.internal.JDAImpl
import net.dv8tion.jda.internal.entities.ReceivedMessage
import net.dv8tion.jda.internal.requests.FunctionalCallback
import net.dv8tion.jda.internal.utils.*
import okhttp3.Call
import okhttp3.Request
import okhttp3.Request.Builder.addHeader
import okhttp3.Request.Builder.build
import okhttp3.Request.Builder.url
import okhttp3.Response
import java.io.*
import java.time.OffsetDateTime
import java.util.*
import java.util.concurrent.CompletableFuture
import java.util.function.Predicate
import java.util.regex.Pattern
import java.util.stream.Collectors
import javax.annotation.CheckReturnValue
import javax.annotation.Nonnull

/**
 * Represents a Text message received from Discord.
 * <br></br>This represents messages received from [MessageChannels][MessageChannel].
 *
 *
 * **This type is not updated. JDA does not keep track of changes to messages, it is advised to do this via events such
 * as [MessageUpdateEvent][net.dv8tion.jda.api.events.message.MessageUpdateEvent] and similar.**
 *
 *
 * **Message Differences**<br></br>
 * There are 2 implementations of this interface in JDA.
 *
 *  1. **Received Message**
 * <br></br>Messages received through events or history query.
 * These messages hold information of **existing** messages and
 * can be modified or deleted.
 *  1. **System Message**
 * <br></br>Specification of **Received Messages** that are generated by Discord
 * on certain events. Commonly this is used in groups or to indicate a pin within a MessageChannel.
 * The different types can be found in the [MessageType][net.dv8tion.jda.api.entities.MessageType] enum.
 *
 *
 *
 * When a feature is not available it will throw an [UnsupportedOperationException][java.lang.UnsupportedOperationException]
 * as per interface specifications.
 * <br></br>Specific operations may have specified information available in the `throws` javadoc.
 *
 *
 * **Formattable**<br></br>
 * This interface extends [Formattable][java.util.Formattable] and can be used with a [Formatter][java.util.Formatter]
 * such as used by [String.format(String, Object...)][String.format]
 * or [PrintStream.printf(String, Object...)][java.io.PrintStream.printf].
 *
 *
 * This will use [.getContentDisplay] rather than [Object.toString]!
 * <br></br>Supported Features:
 *
 *  * **Alternative**
 * <br></br>   - Using [.getContentRaw]
 * (Example: `%#s` - uses [.getContentDisplay])
 *
 *  * **Width/Left-Justification**
 * <br></br>   - Ensures the size of a format
 * (Example: `%20s` - uses at minimum 20 chars;
 * `%-10s` - uses left-justified padding)
 *
 *  * **Precision**
 * <br></br>   - Cuts the content to the specified size
 * (replacing last 3 chars with `...`; Example: `%.20s`)
 *
 *
 *
 * More information on formatting syntax can be found in the [format syntax documentation][java.util.Formatter]!
 *
 * @see MessageChannel.getIterableHistory
 * @see MessageChannel.getHistory
 * @see MessageChannel.getHistoryAfter
 * @see MessageChannel.getHistoryBefore
 * @see MessageChannel.getHistoryAround
 * @see MessageChannel.getHistoryFromBeginning
 * @see MessageChannel.retrieveMessageById
 * @see MessageChannel.deleteMessageById
 * @see MessageChannel.editMessageById
 */
interface Message : ISnowflake, Formattable {
    /**
     * Returns the [MessageReference] for this Message. This will be null if this Message has no reference.
     *
     *
     * You can access all the information about a reference through this object.
     * Additionally, you can retrieve the referenced Message if discord did not load it in time. This can be done with [MessageReference.resolve].
     *
     * @return The message reference, or null.
     */
    val messageReference: MessageReference?
    val referencedMessage: Message?
        /**
         * Referenced message.
         *
         *
         * This will have different meaning depending on the [type][.getType] of message.
         * Usually, this is a [INLINE_REPLY][MessageType.INLINE_REPLY] reference.
         * This can be null even if the type is [INLINE_REPLY][MessageType.INLINE_REPLY], when the message it references doesn't exist or discord wasn't able to resolve it in time.
         *
         *
         * This differs from a [MessageReference], which contains the raw IDs attached to the reference, and allows you to retrieve the referenced message
         *
         * @return The referenced message, or null
         *
         * @see .getMessageReference
         */
        get() = if (messageReference != null) messageReference.getMessage() else null

    @get:Nonnull
    val mentions: Mentions?

    /**
     * Returns whether or not this Message has been edited before.
     *
     * @return True if this message has been edited.
     */
    val isEdited: Boolean

    /**
     * Provides the [OffsetDateTime][java.time.OffsetDateTime] defining when this Message was last
     * edited. If this Message has not been edited ([.isEdited] is `false`), then this method
     * will return `null`.
     *
     * @return Time of the most recent edit, or `null` if the Message has never been edited.
     */
    val timeEdited: OffsetDateTime?

    @JvmField
    @get:Nonnull
    val author: User?

    /**
     * Returns the author of this Message as a [member][net.dv8tion.jda.api.entities.Member].
     * <br></br>**This is only valid if the Message was actually sent in a GuildMessageChannel.** This will return `null`
     * if the message was not sent in a GuildMessageChannel, or if the message was sent by a Webhook.
     * <br></br>You can check the type of channel this message was sent from using [.isFromType] or [.getChannelType].
     *
     *
     * Discord does not provide a member object for messages returned by [RestActions][RestAction] of any kind.
     * This will return null if the message was retrieved through [MessageChannel.retrieveMessageById] or similar means,
     * unless the member is already cached.
     *
     * @return Message author, or `null` if the message was not sent in a GuildMessageChannel, or if the message was sent by a Webhook.
     *
     * @see .isWebhookMessage
     */
    @JvmField
    val member: Member?

    /**
     * Returns the approximate position of this message in a [ThreadChannel].
     * <br></br>This can be used to estimate the relative position of a message in a thread, by comparing against [ThreadChannel.getTotalMessageCount].
     *
     *
     * **Notes:**
     *
     *  * The position might contain gaps or duplicates.
     *  * The position is not set on messages sent earlier than July 19th, 2022, and will return -1.
     *
     *
     * @throws IllegalStateException
     * If this message was not sent in a [ThreadChannel].
     *
     * @return The approximate position of this message, or `-1` if this message is too old.
     *
     * @see [Discord docs: `position` property on the message object](https://discord.com/developers/docs/resources/channel.message-object)
     */
    val approximatePosition: Int

    @get:Nonnull
    val jumpUrl: String?

    @JvmField
    @get:Nonnull
    val contentDisplay: String?

    @JvmField
    @get:Nonnull
    val contentRaw: String?

    @JvmField
    @get:Nonnull
    val contentStripped: String?

    @get:Nonnull
    val invites: List<String?>?

    /**
     * Validation [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce) for this Message
     * <br></br>This can be used to validate that a Message was properly sent to the Discord Service.
     * <br></br>To set a nonce before sending you may use [MessageCreateAction.setNonce(String)][MessageCreateAction.setNonce]!
     *
     * @return The validation nonce
     *
     * @see MessageCreateAction.setNonce
     * @see [Cryptographic Nonce - Wikipedia](https://en.wikipedia.org/wiki/Cryptographic_nonce)
     */
    @JvmField
    val nonce: String?

    /**
     * Used to determine if this Message was received from a [MessageChannel]
     * of the [ChannelType][net.dv8tion.jda.api.entities.channel.ChannelType] specified.
     *
     *
     * Useful for restricting functionality to a certain type of channels.
     *
     * @param  type
     * The [ChannelType] to check against.
     *
     * @return True if the [ChannelType][net.dv8tion.jda.api.entities.channel.ChannelType] which this message was received
     * from is the same as the one specified by `type`.
     */
    fun isFromType(@Nonnull type: ChannelType?): Boolean

    /**
     * Whether this message was sent in a [Guild].
     * <br></br>If this is `false` then [.getGuild] will throw an [java.lang.IllegalStateException].
     *
     * @return True, if [.getChannelType].[isGuild()][ChannelType.isGuild] is true.
     */
    val isFromGuild: Boolean

    @JvmField
    @get:Nonnull
    val channelType: ChannelType?

    /**
     * Indicates if this Message was sent by a [Webhook][net.dv8tion.jda.api.entities.Webhook] instead of a
     * [User].
     * <br></br>Useful if you want to ignore non-users.
     *
     * @return True if this message was sent by a [Webhook][net.dv8tion.jda.api.entities.Webhook].
     */
    @JvmField
    val isWebhookMessage: Boolean
    val applicationId: String?
        /**
         * If this message is from an application-owned [Webhook][net.dv8tion.jda.api.entities.Webhook] or
         * is a response to an [Interaction][net.dv8tion.jda.api.interactions.Interaction], this will return
         * the application's id.
         *
         * @return The application's id or `null` if this message was not sent by an application
         */
        get() = if (applicationIdLong == 0L) null else java.lang.Long.toUnsignedString(applicationIdLong)

    /**
     * If this message is from an application-owned [Webhook][net.dv8tion.jda.api.entities.Webhook] or
     * is a response to an [Interaction][net.dv8tion.jda.api.interactions.Interaction], this will return
     * the application's id.
     *
     * @return The application's id or 0 if this message was not sent by an application
     */
    val applicationIdLong: Long

    /**
     * Whether this message instance has an available [.getChannel].
     *
     *
     * This can be `false` for messages sent via webhooks, or in the context of interactions.
     *
     * @return True, if [.getChannel] is available
     */
    fun hasChannel(): Boolean

    /**
     * The ID for the channel this message was sent in.
     * <br></br>This is useful when [.getChannel] is unavailable, for instance on webhook messages.
     *
     * @return The channel id
     */
    val channelIdLong: Long

    @get:Nonnull
    val channelId: String?
        /**
         * The ID for the channel this message was sent in.
         * <br></br>This is useful when [.getChannel] is unavailable, for instance on webhook messages.
         *
         * @return The channel id
         */
        get() = java.lang.Long.toUnsignedString(channelIdLong)

    @JvmField
    @get:Nonnull
    val channel: MessageChannelUnion

    @get:Nonnull
    val guildChannel: GuildMessageChannelUnion

    /**
     * The [Category] this
     * message was sent in. This will always be `null` for DMs.
     * <br></br>Equivalent to `getGuildChannel().getParentCategory()` if this was sent in a [GuildMessageChannel].
     *
     * @return [Category][net.dv8tion.jda.api.entities.channel.concrete.Category] for this message
     */
    val category: Category?

    /**
     * Whether this message instance provides a guild instance via [.getGuild].
     * <br></br>This is different from [.isFromGuild], which checks whether the message was sent in a guild.
     * This method describes whether [.getGuild] is usable.
     *
     *
     * This can be `false` for messages sent via webhooks, or in the context of interactions.
     *
     * @return True, if [.getGuild] is provided
     */
    fun hasGuild(): Boolean

    /**
     * The ID for the guild this message was sent in.
     * <br></br>This is useful when [.getGuild] is not provided, for instance on webhook messages.
     *
     * @return The guild id, or 0 if this message was not sent in a guild
     */
    val guildIdLong: Long
    val guildId: String?
        /**
         * The ID for the guild this message was sent in.
         * <br></br>This is useful when [.getGuild] is not provided, for instance on webhook messages.
         *
         * @return The guild id, or null if this message was not sent in a guild
         */
        get() = if (isFromGuild) java.lang.Long.toUnsignedString(guildIdLong) else null

    @get:Nonnull
    val guild: Guild?

    @JvmField
    @get:Nonnull
    val attachments: List<Attachment?>?

    @JvmField
    @get:Nonnull
    val embeds: List<MessageEmbed?>?

    @get:Nonnull
    val components: List<LayoutComponent>

    @get:Nonnull
    val actionRows: List<ActionRow>?
        /**
         * Rows of interactive components such as [Buttons][Button].
         * <br></br>You can use [MessageRequest.setComponents] to update these.
         *
         *
         * **Requires [GatewayIntent.MESSAGE_CONTENT][net.dv8tion.jda.api.requests.GatewayIntent.MESSAGE_CONTENT]**
         *
         * @return Immutable [List] of [ActionRow]
         *
         * @see .getButtons
         * @see .getButtonById
         */
        get() = components
            .stream()
            .filter { obj: LayoutComponent? -> ActionRow::class.java.isInstance(obj) }
            .map { obj: LayoutComponent? -> ActionRow::class.java.cast(obj) }
            .collect(Helpers.toUnmodifiableList())

    @get:Nonnull
    val buttons: List<Button?>
        /**
         * All [Buttons][Button] attached to this message.
         *
         *
         * **Requires [GatewayIntent.MESSAGE_CONTENT][net.dv8tion.jda.api.requests.GatewayIntent.MESSAGE_CONTENT]**
         *
         * @return Immutable [List] of [Buttons][Button]
         */
        get() = components.stream()
            .map { obj: LayoutComponent -> obj.buttons }
            .flatMap { obj: List<Button?> -> obj.stream() }
            .collect(Helpers.toUnmodifiableList())

    /**
     * Gets the [Button] with the specified ID.
     *
     *
     * **Requires [GatewayIntent.MESSAGE_CONTENT][net.dv8tion.jda.api.requests.GatewayIntent.MESSAGE_CONTENT]**
     *
     * @param  id
     * The id of the button
     *
     * @throws IllegalArgumentException
     * If the id is null
     *
     * @return The [Button] or null of no button with that ID is present on this message
     */
    fun getButtonById(@Nonnull id: String): Button? {
        Checks.notNull(id, "Button ID")
        return buttons.stream()
            .filter { it: Button? -> id == it!!.id }
            .findFirst().orElse(null)
    }

    /**
     * All [Buttons][Button] with the specified label attached to this message.
     *
     *
     * **Requires [GatewayIntent.MESSAGE_CONTENT][net.dv8tion.jda.api.requests.GatewayIntent.MESSAGE_CONTENT]**
     *
     * @param  label
     * The button label
     * @param  ignoreCase
     * Whether to use [String.equalsIgnoreCase] instead of [String.equals]
     *
     * @throws IllegalArgumentException
     * If the provided label is null
     *
     * @return Immutable [List] of [Buttons][Button] with the specified label
     */
    @Nonnull
    fun getButtonsByLabel(@Nonnull label: String, ignoreCase: Boolean): List<Button?>? {
        Checks.notNull(label, "Label")
        val filter: Predicate<Button?>
        filter = if (ignoreCase) Predicate { b: Button? ->
            label.equals(
                b!!.label, ignoreCase = true
            )
        } else Predicate { b: Button? -> label == b!!.label }
        return buttons.stream()
            .filter(filter)
            .collect(Helpers.toUnmodifiableList())
    }

    @get:Nonnull
    val reactions: List<MessageReaction?>?

    @get:Nonnull
    val stickers: List<StickerItem?>?

    /**
     * Defines whether or not this Message triggers TTS (Text-To-Speech).
     *
     * @return If this message is TTS.
     */
    @JvmField
    val isTTS: Boolean

    /**
     * A [MessageActivity][net.dv8tion.jda.api.entities.MessageActivity] that contains its type and party id.
     *
     * @return The activity, or `null` if no activity was added to the message.
     */
    val activity: MessageActivity?

    /**
     * Edits this message and updates the content.
     * <br></br>Any other fields of the message will remain unchanged,
     * you can use [replace(true)][net.dv8tion.jda.api.utils.messages.MessageEditRequest.setReplace] to remove everything else (embeds/attachments/components).
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @param  newContent
     * The new content of the message, or empty string to remove content (assumes other fields exist like embeds)
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     * If null is provided or the new content is longer than {@value #MAX_CONTENT_LENGTH} characters
     *
     * @return [MessageEditAction]
     *
     * @see MessageChannel.editMessageById
     */
    @Nonnull
    @CheckReturnValue
    fun editMessage(@Nonnull newContent: CharSequence?): MessageEditAction?

    /**
     * Edits this message using the provided [MessageEditData].
     * <br></br>You can use [MessageEditBuilder][net.dv8tion.jda.api.utils.messages.MessageEditBuilder] to create a [MessageEditData] instance.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @param  data
     * The [MessageEditData] used to update the message
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     * If null is provided
     *
     * @return [MessageEditAction]
     *
     * @see net.dv8tion.jda.api.utils.messages.MessageEditBuilder MessageEditBuilder
     *
     * @see MessageChannel.editMessageById
     */
    @Nonnull
    @CheckReturnValue
    fun editMessage(@Nonnull data: MessageEditData?): MessageEditAction?

    /**
     * Edits this message using the provided [MessageEmbeds][MessageEmbed].
     * <br></br>You can use [EmbedBuilder][net.dv8tion.jda.api.EmbedBuilder] to create a [MessageEmbed] instance.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @param  embeds
     * The new [MessageEmbeds][MessageEmbed] of the message, empty list to remove embeds
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     *
     *  * If `null` is provided
     *  * If more than {@value Message#MAX_EMBED_COUNT} embeds are provided
     *
     *
     * @return [MessageEditAction]
     *
     * @see net.dv8tion.jda.api.EmbedBuilder EmbedBuilder
     *
     * @see MessageChannel.editMessageEmbedsById
     */
    @Nonnull
    @CheckReturnValue
    fun editMessageEmbeds(@Nonnull embeds: Collection<MessageEmbed?>?): MessageEditAction?

    /**
     * Edits this message using the provided [MessageEmbeds][MessageEmbed].
     * <br></br>You can use [EmbedBuilder][net.dv8tion.jda.api.EmbedBuilder] to create a [MessageEmbed] instance.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @param  embeds
     * The new [MessageEmbeds][MessageEmbed] of the message, or an empty list to remove all embeds
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     *
     *  * If `null` is provided
     *  * If more than {@value Message#MAX_EMBED_COUNT} embeds are provided
     *
     *
     * @return [MessageEditAction]
     *
     * @see net.dv8tion.jda.api.EmbedBuilder EmbedBuilder
     *
     * @see MessageChannel.editMessageEmbedsById
     */
    @Nonnull
    @CheckReturnValue
    fun editMessageEmbeds(@Nonnull vararg embeds: MessageEmbed?): MessageEditAction? {
        Checks.noneNull(embeds, "MessageEmbeds")
        return editMessageEmbeds(Arrays.asList(*embeds))
    }

    /**
     * Edits this message using the provided [LayoutComponents][LayoutComponent].
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @param  components
     * The new [LayoutComponents][LayoutComponent] of the message, or an empty list to remove all components
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     *
     *  * If `null` is provided
     *  * If any of the components is not [message compatible][LayoutComponent.isMessageCompatible]
     *  * If more than {@value Message#MAX_COMPONENT_COUNT} components are provided
     *
     *
     * @return [MessageEditAction]
     *
     * @see MessageChannel.editMessageComponentsById
     */
    @Nonnull
    @CheckReturnValue
    fun editMessageComponents(@Nonnull components: Collection<LayoutComponent?>?): MessageEditAction?

    /**
     * Edits this message using the provided [LayoutComponents][LayoutComponent].
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @param  components
     * The new [LayoutComponents][LayoutComponent] of the message, empty list to remove all components
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     *
     *  * If `null` is provided
     *  * If any of the components is not [message compatible][LayoutComponent.isMessageCompatible]
     *  * If more than {@value Message#MAX_COMPONENT_COUNT} components are provided
     *
     *
     * @return [MessageEditAction]
     *
     * @see MessageChannel.editMessageComponentsById
     */
    @Nonnull
    @CheckReturnValue
    fun editMessageComponents(@Nonnull vararg components: LayoutComponent?): MessageEditAction? {
        Checks.noneNull(components, "Components")
        return editMessageComponents(Arrays.asList(*components))
    }

    /**
     * Edits this message using the provided format arguments.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @param  format
     * Format String used to generate new Content
     * @param  args
     * The arguments which should be used to format the given format String
     *
     * @throws IllegalArgumentException
     * If provided `format` is `null` or blank.
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If this is a [GuildMessageChannel] and this account does not have
     * [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * @throws java.util.IllegalFormatException
     * If a format string contains an illegal syntax,
     * a format specifier that is incompatible with the given arguments,
     * insufficient arguments given the format string, or other illegal conditions.
     * For specification of all possible formatting errors,
     * see the [Details](../util/Formatter.html#detail)
     * section of the formatter class specification.
     *
     * @return [MessageEditAction]
     *
     * @see MessageChannel.editMessageFormatById
     */
    @Nonnull
    @CheckReturnValue
    fun editMessageFormat(@Nonnull format: String?, @Nonnull vararg args: Any?): MessageEditAction?

    /**
     * Edits this message using the provided files.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [REQUEST_ENTITY_TOO_LARGE][net.dv8tion.jda.api.requests.ErrorResponse.REQUEST_ENTITY_TOO_LARGE]
     * <br></br>If any of the provided files is bigger than [Guild.getMaxFileSize]
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted. This might also be triggered for ephemeral messages.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     *
     * **Resource Handling Note:** Once the request is handed off to the requester, for example when you call [RestAction.queue],
     * the requester will automatically clean up all opened files by itself. You are only responsible to close them yourself if it is never handed off properly.
     * For instance, if an exception occurs after using [FileUpload.fromData], before calling [RestAction.queue].
     * You can safely use a try-with-resources to handle this, since [FileUpload.close] becomes ineffective once the request is handed off.
     *
     * @param  attachments
     * The new attachments of the message (Can be [FileUploads][FileUpload] or [AttachmentUpdates][net.dv8tion.jda.api.utils.AttachmentUpdate])
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     * If `null` is provided
     *
     * @return [MessageEditAction] that can be used to further update the message
     *
     * @see AttachedFile.fromAttachment
     * @see FileUpload.fromData
     */
    @Nonnull
    @CheckReturnValue
    fun editMessageAttachments(@Nonnull attachments: Collection<AttachedFile?>?): MessageEditAction?

    /**
     * Edits this message using the provided files.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [REQUEST_ENTITY_TOO_LARGE][net.dv8tion.jda.api.requests.ErrorResponse.REQUEST_ENTITY_TOO_LARGE]
     * <br></br>If any of the provided files is bigger than [Guild.getMaxFileSize]
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL][net.dv8tion.jda.api.Permission.VIEW_CHANNEL]
     * was revoked in the [GuildMessageChannel]
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>The provided `messageId` is unknown in this MessageChannel, either due to the id being invalid, or
     * the message it referred to has already been deleted. This might also be triggered for ephemeral messages.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     *
     * **Resource Handling Note:** Once the request is handed off to the requester, for example when you call [RestAction.queue],
     * the requester will automatically clean up all opened files by itself. You are only responsible to close them yourself if it is never handed off properly.
     * For instance, if an exception occurs after using [FileUpload.fromData], before calling [RestAction.queue].
     * You can safely use a try-with-resources to handle this, since [FileUpload.close] becomes ineffective once the request is handed off.
     *
     * @param  attachments
     * The new attachments of the message (Can be [FileUploads][FileUpload] or [AttachmentUpdates][net.dv8tion.jda.api.utils.AttachmentUpdate])
     *
     * @throws UnsupportedOperationException
     * If this is a system message
     * @throws IllegalStateException
     * If the message is not authored by this bot
     * @throws IllegalArgumentException
     * If `null` is provided
     *
     * @return [MessageEditAction] that can be used to further update the message
     *
     * @see AttachedFile.fromAttachment
     * @see FileUpload.fromData
     */
    @Nonnull
    @CheckReturnValue
    fun editMessageAttachments(@Nonnull vararg attachments: AttachedFile?): MessageEditAction? {
        Checks.noneNull(attachments, "Attachments")
        return editMessageAttachments(Arrays.asList(*attachments))
    }

    /**
     * Replies and references this message.
     * <br></br>This is identical to `message.getGuildChannel().sendStickers(stickers).reference(message)`.
     * You can use [mentionRepliedUser(false)][MessageCreateAction.mentionRepliedUser] to not mention the author of the message.
     * <br></br>By default there won't be any error thrown if the referenced message does not exist.
     * This behavior can be changed with [MessageCreateAction.failOnInvalidReply].
     *
     *
     * For further info, see [GuildMessageChannel.sendStickers] and [MessageCreateAction.setMessageReference].
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  stickers
     * The 1-3 stickers to send
     *
     * @throws MissingAccessException
     * If the currently logged in account does not have [Permission.VIEW_CHANNEL] in this channel
     * @throws InsufficientPermissionException
     *
     *  * If this is a [ThreadChannel] and the bot does not have [Permission.MESSAGE_SEND_IN_THREADS]
     *  * If this is not a [ThreadChannel] and the bot does not have [Permission.MESSAGE_SEND]
     *
     * @throws IllegalArgumentException
     *
     *  * If any of the provided stickers is a [GuildSticker],
     * which is either [unavailable][GuildSticker.isAvailable] or from a different guild.
     *  * If the list is empty or has more than 3 stickers
     *  * If null is provided
     *
     * @throws IllegalStateException
     * If this message was not sent in a [Guild]
     *
     * @return [MessageCreateAction]
     *
     * @see Sticker.fromId
     */
    @Nonnull
    @CheckReturnValue
    fun replyStickers(@Nonnull stickers: Collection<StickerSnowflake?>?): MessageCreateAction? {
        return guildChannel.sendStickers(stickers)!!.setMessageReference(this)
    }

    /**
     * Replies and references this message.
     * <br></br>This is identical to `message.getGuildChannel().sendStickers(stickers).reference(message)`.
     * You can use [mentionRepliedUser(false)][MessageCreateAction.mentionRepliedUser] to not mention the author of the message.
     * <br></br>By default there won't be any error thrown if the referenced message does not exist.
     * This behavior can be changed with [MessageCreateAction.failOnInvalidReply].
     *
     *
     * For further info, see [GuildMessageChannel.sendStickers] and [MessageCreateAction.setMessageReference].
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  stickers
     * The 1-3 stickers to send
     *
     * @throws MissingAccessException
     * If the currently logged in account does not have [Permission.VIEW_CHANNEL] in this channel
     * @throws InsufficientPermissionException
     *
     *  * If this is a [ThreadChannel] and the bot does not have [Permission.MESSAGE_SEND_IN_THREADS]
     *  * If this is not a [ThreadChannel] and the bot does not have [Permission.MESSAGE_SEND]
     *
     * @throws IllegalArgumentException
     *
     *  * If any of the provided stickers is a [GuildSticker],
     * which is either [unavailable][GuildSticker.isAvailable] or from a different guild.
     *  * If the list is empty or has more than 3 stickers
     *  * If null is provided
     *
     * @throws IllegalStateException
     * If this message was not sent in a [Guild]
     *
     * @return [MessageCreateAction]
     *
     * @see Sticker.fromId
     */
    @Nonnull
    @CheckReturnValue
    fun replyStickers(@Nonnull vararg stickers: StickerSnowflake?): MessageCreateAction? {
        return guildChannel.sendStickers(*stickers)!!.setMessageReference(this)
    }

    /**
     * Shortcut for `getChannel().sendMessage(content).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  content
     * The reply content
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendMessage] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendMessage] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun reply(@Nonnull content: CharSequence?): MessageCreateAction? {
        return channel.sendMessage(content!!)!!.setMessageReference(this)
    }

    /**
     * Shortcut for `getChannel().sendMessage(data).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  msg
     * The [MessageCreateData] to send
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendMessage] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendMessage] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun reply(@Nonnull msg: MessageCreateData?): MessageCreateAction? {
        return channel.sendMessage(msg)!!.setMessageReference(this)
    }

    /**
     * Shortcut for `getChannel().sendMessageEmbeds(embed, other).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  embed
     * The [MessageEmbed] to send
     * @param  other
     * Any addition [MessageEmbeds][MessageEmbed] to send
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendMessageEmbeds] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendMessageEmbeds] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun replyEmbeds(@Nonnull embed: MessageEmbed?, @Nonnull vararg other: MessageEmbed?): MessageCreateAction? {
        Checks.notNull(embed, "MessageEmbeds")
        Checks.noneNull(other, "MessageEmbeds")
        val embeds: MutableList<MessageEmbed?> = ArrayList(1 + other.size)
        embeds.add(embed)
        Collections.addAll(embeds, *other)
        return replyEmbeds(embeds)
    }

    /**
     * Shortcut for `getChannel().sendMessageEmbeds(embeds).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  embeds
     * The [MessageEmbeds][MessageEmbed] to send
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendMessageEmbeds] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendMessageEmbeds] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun replyEmbeds(@Nonnull embeds: Collection<MessageEmbed?>?): MessageCreateAction? {
        return channel.sendMessageEmbeds(embeds)!!.setMessageReference(this)
    }

    /**
     * Shortcut for `getChannel().sendMessageComponents(component, other).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  component
     * The [LayoutComponent] to send
     * @param  other
     * Any addition [LayoutComponents][LayoutComponent] to send
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendMessageComponents] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendMessageComponents] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun replyComponents(
        @Nonnull component: LayoutComponent?,
        @Nonnull vararg other: LayoutComponent?
    ): MessageCreateAction? {
        Checks.notNull(component, "LayoutComponents")
        Checks.noneNull(other, "LayoutComponents")
        val components: MutableList<LayoutComponent?> = ArrayList(1 + other.size)
        components.add(component)
        Collections.addAll(components, *other)
        return replyComponents(components)
    }

    /**
     * Shortcut for `getChannel().sendMessageComponents(components).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  components
     * The [LayoutComponents][LayoutComponent] to send
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendMessageComponents] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendMessageComponents] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun replyComponents(@Nonnull components: Collection<LayoutComponent?>?): MessageCreateAction? {
        return channel.sendMessageComponents(components)!!.setMessageReference(this)
    }

    /**
     * Shortcut for `getChannel().sendMessageFormat(format, args).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  format
     * The format string
     * @param  args
     * The arguments to use in the format string
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendMessageFormat] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendMessageFormat] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun replyFormat(@Nonnull format: String?, @Nonnull vararg args: Any?): MessageCreateAction? {
        return channel.sendMessageFormat(format, *args)!!.setMessageReference(this)
    }

    /**
     * Shortcut for `getChannel().sendFiles(files).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  files
     * The [FileUploads][FileUpload] to send
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendFiles] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendFiles] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun replyFiles(@Nonnull vararg files: FileUpload?): MessageCreateAction? {
        return channel.sendFiles(*files)!!.setMessageReference(this)
    }

    /**
     * Shortcut for `getChannel().sendFiles(files).setMessageReference(this)`.
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] include:
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If this message no longer exists
     *
     *  * [MESSAGE_BLOCKED_BY_AUTOMOD][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_AUTOMOD]
     * <br></br>If this message was blocked by an [AutoModRule][net.dv8tion.jda.api.entities.automod.AutoModRule]
     *
     *  * [MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER][net.dv8tion.jda.api.requests.ErrorResponse.MESSAGE_BLOCKED_BY_HARMFUL_LINK_FILTER]
     * <br></br>If this message was blocked by the harmful link filter
     *
     *
     * @param  files
     * The [FileUploads][FileUpload] to send
     *
     * @throws InsufficientPermissionException
     * If [MessageChannel.sendFiles] throws
     * @throws IllegalArgumentException
     * If [MessageChannel.sendFiles] throws
     *
     * @return [MessageCreateAction]
     */
    @Nonnull
    @CheckReturnValue
    fun replyFiles(@Nonnull files: Collection<FileUpload?>?): MessageCreateAction? {
        return channel.sendFiles(files)!!.setMessageReference(this)
    }

    /**
     * Deletes this Message from Discord.
     * <br></br>If this Message was not sent by the currently logged in account, then this will fail unless the Message is from
     * a [GuildChannel] and the current account has
     * [Permission.MESSAGE_MANAGE] in the channel.
     *
     *
     * <u>To delete many messages at once in a [MessageChannel]
     * you should use [MessageChannel.purgeMessages(List)][MessageChannel.purgeMessages] instead.</u>
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The delete was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked, or the
     * account lost access to the [Guild]
     * typically due to being kicked or removed.
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The delete was attempted after the account lost [Permission.MESSAGE_MANAGE] in
     * the [GuildChannel] when deleting another Member's message
     * or lost [Permission.MESSAGE_MANAGE].
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @throws MissingAccessException
     * If the currently logged in account does not have [access][Member.hasAccess] in this channel.
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If this Message was not sent by the currently logged in account, the Message was sent in a
     * [GuildChannel], and the currently logged in account
     * does not have [Permission.MESSAGE_MANAGE] in
     * the channel.
     * @throws java.lang.IllegalStateException
     *
     *  * If this Message was not sent by the currently logged in account and it was **not** sent in a
     * [GuildChannel].
     *  * If this Message is ephemeral
     *  * If this message type cannot be deleted. (See [MessageType.canDelete])
     *
     *
     * @return [AuditableRestAction][net.dv8tion.jda.api.requests.restaction.AuditableRestAction]
     *
     * @see TextChannel.deleteMessages
     * @see MessageChannel.purgeMessages
     */
    @Nonnull
    @CheckReturnValue
    fun delete(): AuditableRestAction<Void?>?

    @JvmField
    @get:Nonnull
    val jDA: JDA?

    /**
     * Whether or not this Message has been pinned in its parent channel.
     *
     * @return True - if this message has been pinned.
     */
    val isPinned: Boolean

    /**
     * Used to add the Message to the [MessageChannel&#39;s][.getChannel] pinned message list.
     * <br></br>This is a shortcut method to [MessageChannel.pinMessageById].
     *
     *
     * The success or failure of this action will not affect the return of [.isPinned].
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The pin request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked, or the
     * account lost access to the [Guild]
     * typically due to being kicked or removed.
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The pin request was attempted after the account lost [Permission.MESSAGE_MANAGE] in
     * the [GuildChannel].
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If this Message is from a [GuildChannel] and:
     * <br></br>
     *  * Missing [Permission.VIEW_CHANNEL].
     * <br></br>The account needs access the the channel to pin a message in it.
     *  * Missing [Permission.MESSAGE_MANAGE].
     * <br></br>Required to actually pin the Message.
     *
     * @throws IllegalStateException
     * If this Message is ephemeral
     *
     * @return [RestAction] - Type: [java.lang.Void]
     */
    @Nonnull
    @CheckReturnValue
    fun pin(): RestAction<Void?>?

    /**
     * Used to remove the Message from the [MessageChannel&#39;s][.getChannel] pinned message list.
     * <br></br>This is a shortcut method to [MessageChannel.unpinMessageById].
     *
     *
     * The success or failure of this action will not affect the return of [.isPinned].
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The unpin request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked, or the
     * account lost access to the [Guild]
     * typically due to being kicked or removed.
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The unpin request was attempted after the account lost [Permission.MESSAGE_MANAGE] in
     * the [GuildChannel].
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If this Message is from a [GuildChannel] and:
     * <br></br>
     *  * Missing [Permission.VIEW_CHANNEL].
     * <br></br>The account needs access the the channel to pin a message in it.
     *  * Missing [Permission.MESSAGE_MANAGE].
     * <br></br>Required to actually pin the Message.
     *
     * @throws IllegalStateException
     * If this Message is ephemeral
     *
     * @return [RestAction] - Type: [java.lang.Void]
     */
    @Nonnull
    @CheckReturnValue
    fun unpin(): RestAction<Void?>?

    /**
     * Adds a reaction to this Message using an [Emoji].
     *
     *
     * This message instance will not be updated by this operation.
     *
     *
     * Reactions are the small emoji below a message that have a counter beside them
     * showing how many users have reacted with the same emoji.
     *
     *
     * **Neither success nor failure of this request will affect this Message's [.getReactions] return as Message is immutable.**
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The reaction request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked
     * <br></br>Also can happen if the account lost the [Permission.MESSAGE_HISTORY]
     *
     *  * [REACTION_BLOCKED][net.dv8tion.jda.api.requests.ErrorResponse.REACTION_BLOCKED]
     * <br></br>The user has blocked the currently logged in account and the reaction failed
     *
     *  * [TOO_MANY_REACTIONS][net.dv8tion.jda.api.requests.ErrorResponse.TOO_MANY_REACTIONS]
     * <br></br>The message already has too many reactions to proceed
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The reaction request was attempted after the account lost [Permission.MESSAGE_ADD_REACTION]
     * or [Permission.MESSAGE_HISTORY]
     * in the [GuildChannel] when adding the reaction.
     *
     *  * [UNKNOWN_EMOJI][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_EMOJI]
     * <br></br>The provided emoji was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @param  emoji
     * The [Emoji] to add as a reaction to this Message.
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If the MessageChannel this message was sent in was a [GuildChannel]
     * and the logged in account does not have
     *
     *  * [Permission.MESSAGE_ADD_REACTION]
     *  * [Permission.MESSAGE_HISTORY]
     *
     * @throws java.lang.IllegalArgumentException
     *
     *  * If the provided [Emoji] is null.
     *  * If the provided [Emoji] is a custom emoji and cannot be used in the current channel.
     * See [RichCustomEmoji.canInteract] or [RichCustomEmoji.canInteract] for more information.
     *
     * @throws IllegalStateException
     * If this message is ephemeral
     *
     * @return [RestAction]
     */
    @Nonnull
    @CheckReturnValue
    fun addReaction(@Nonnull emoji: Emoji?): RestAction<Void?>?

    /**
     * Removes all reactions from this Message.
     * <br></br>This is useful for moderator commands that wish to remove all reactions at once from a specific message.
     *
     *
     * Please note that you **can't** clear reactions if this message was sent in a [PrivateChannel]!
     *
     *
     * **Neither success nor failure of this request will affect this Message's [.getReactions] return as Message is immutable.**
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The clear-reactions request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked, or the
     * account lost access to the [Guild]
     * typically due to being kicked or removed.
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The clear-reactions request was attempted after the account lost [Permission.MESSAGE_MANAGE]
     * in the [GuildChannel] when adding the reaction.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If the MessageChannel this message was sent in was a [GuildChannel]
     * and the currently logged in account does not have [Permission.MESSAGE_MANAGE]
     * in the channel.
     * @throws java.lang.IllegalStateException
     *
     *  * If this message was **not** sent in a [Guild].
     *  * If this message is ephemeral
     *
     *
     *
     * @return [RestAction]
     */
    @Nonnull
    @CheckReturnValue
    fun clearReactions(): RestAction<Void?>?

    /**
     * Removes all reactions for the specified [Emoji].
     *
     *
     * Please note that you **can't** clear reactions if this message was sent in a [PrivateChannel]!
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The currently logged in account lost access to the channel by either being removed from the guild
     * or losing the [VIEW_CHANNEL][Permission.VIEW_CHANNEL] permission
     *
     *  * [UNKNOWN_EMOJI][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_EMOJI]
     * <br></br>The provided emoji was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @param  emoji
     * The [Emoji] to remove reactions for
     *
     * @throws InsufficientPermissionException
     * If the currently logged in account does not have [Permission.MESSAGE_MANAGE] in the channel
     * @throws IllegalArgumentException
     * If provided with null
     * @throws java.lang.IllegalStateException
     *
     *  * If this message was **not** sent in a [Guild].
     *  * If this message is ephemeral
     *
     *
     * @return [RestAction]
     */
    @Nonnull
    @CheckReturnValue
    fun clearReactions(@Nonnull emoji: Emoji?): RestAction<Void?>?

    /**
     * Removes own reaction from this Message using an [Emoji],
     * you can use [.removeReaction] to remove reactions from other users,
     * or [.clearReactions] to remove all reactions for the specified emoji.
     *
     *
     * This message instance will not be updated by this operation.
     *
     *
     * Reactions are the small emojis below a message that have a counter beside them
     * showing how many users have reacted with the same emoji.
     *
     *
     * **Neither success nor failure of this request will affect this Message's [.getReactions] return as Message is immutable.**
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The reaction request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked
     * <br></br>Also can happen if the account lost the [Permission.MESSAGE_HISTORY]
     *
     *  * [UNKNOWN_EMOJI][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_EMOJI]
     * <br></br>The provided emoji was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @param  emoji
     * The [Emoji] reaction to remove as a reaction from this Message.
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If the MessageChannel this message was sent in was a [GuildChannel]
     * and the logged in account does not have [Permission.MESSAGE_HISTORY]
     * @throws java.lang.IllegalArgumentException
     *
     *  * If the provided [Emoji] is null.
     *  * If the provided [Emoji] is a custom emoji and cannot be used in the current channel.
     * See [RichCustomEmoji.canInteract] or [RichCustomEmoji.canInteract] for more information.
     *
     * @throws IllegalStateException
     * If this is an ephemeral message
     *
     * @return [RestAction]
     */
    @Nonnull
    @CheckReturnValue
    fun removeReaction(@Nonnull emoji: Emoji?): RestAction<Void?>?

    /**
     * Removes a [User&#39;s][User] reaction from this Message using an [Emoji].
     *
     *
     * Please note that you **can't** remove reactions of other users if this message was sent in a [PrivateChannel]!
     *
     *
     * This message instance will not be updated by this operation.
     *
     *
     * Reactions are the small emojis below a message that have a counter beside them
     * showing how many users have reacted with the same emoji.
     *
     *
     * **Neither success nor failure of this request will affect this Message's [.getReactions] return as Message is immutable.**
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The reaction request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked
     * <br></br>Also can happen if the account lost the [Permission.MESSAGE_HISTORY]
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The reaction request was attempted after the account lost [Permission.MESSAGE_MANAGE]
     * in the [GuildChannel] when removing the reaction.
     *
     *  * [UNKNOWN_EMOJI][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_EMOJI]
     * <br></br>The provided emoji was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @param  emoji
     * The [Emoji] reaction to remove as a reaction from this Message.
     * @param  user
     * The [User] to remove the reaction for.
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If the MessageChannel this message was sent in was a [GuildChannel]
     * and the logged in account does not have [Permission.MESSAGE_HISTORY].
     * @throws java.lang.IllegalArgumentException
     *
     *  * If the provided `emoji` is null.
     *  * If the provided `emoji` cannot be used in the current channel.
     * See [RichCustomEmoji.canInteract] or [RichCustomEmoji.canInteract] for more information.
     *  * If the provided user is null
     *
     * @throws java.lang.IllegalStateException
     *
     *  * If this message was **not** sent in a
     * [Guild]
     * **and** the given user is **not** the [SelfUser].
     *  * If this message is ephemeral
     *
     *
     *
     * @return [RestAction]
     */
    @Nonnull
    @CheckReturnValue
    fun removeReaction(@Nonnull emoji: Emoji?, @Nonnull user: User?): RestAction<Void?>?

    /**
     * This obtains the [users][User] who reacted using the given [Emoji].
     *
     *
     * Messages maintain a list of reactions, alongside a list of users who added them.
     *
     *
     * Using this data, we can obtain a [ReactionPaginationAction]
     * of the users who've reacted to this message.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The retrieve request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked
     * <br></br>Also can happen if the account lost the [Permission.MESSAGE_HISTORY]
     *
     *  * [UNKNOWN_EMOJI][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_EMOJI]
     * <br></br>The provided emoji was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @param  emoji
     * The [Emoji] to retrieve users for.
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If the MessageChannel this message was sent in was a [GuildChannel] and the
     * logged in account does not have [Permission.MESSAGE_HISTORY] in the channel.
     * @throws java.lang.IllegalArgumentException
     * If the provided [Emoji] is null.
     * @throws IllegalStateException
     * If this Message is ephemeral
     *
     * @return The [ReactionPaginationAction] of the users who reacted with the provided emoji
     */
    @Nonnull
    @CheckReturnValue
    fun retrieveReactionUsers(@Nonnull emoji: Emoji?): ReactionPaginationAction?

    /**
     * This obtains the [MessageReaction] for the given [Emoji] on this message.
     * <br></br>The reaction instance also store which users reacted with the specified emoji.
     *
     *
     * Messages store reactions by keeping a list of reaction names.
     *
     * @param  emoji
     * The unicode or custom emoji of the reaction emoji
     *
     * @throws java.lang.IllegalArgumentException
     * If the provided emoji is null
     *
     * @return The [MessageReaction] or null if not present.
     */
    @CheckReturnValue
    fun getReaction(@Nonnull emoji: Emoji?): MessageReaction?

    /**
     * Enables/Disables suppression of Embeds on this Message.
     * <br></br>Suppressing Embeds is equivalent to pressing the `X` in the top-right corner of an Embed inside the Discord client.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The clear-reactions request was attempted after the account lost access to the [GuildChannel]
     * due to [Permission.VIEW_CHANNEL] being revoked, or the
     * account lost access to the [Guild]
     * typically due to being kicked or removed.
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The suppress-embeds request was attempted after the account lost [Permission.MESSAGE_MANAGE]
     * in the [GuildChannel] when adding the reaction.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *
     * @param  suppressed
     * Whether the embed should be suppressed
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If the MessageChannel this message was sent in was a [GuildChannel]
     * and the currently logged in account does not have
     * [Permission.MESSAGE_MANAGE] in the channel.
     * @throws net.dv8tion.jda.api.exceptions.PermissionException
     * If the MessageChannel this message was sent in was a [PrivateChannel]
     * and the message was not sent by the currently logged in account.
     * @throws IllegalStateException
     * If this Message is ephemeral
     * @return [AuditableRestAction][net.dv8tion.jda.api.requests.restaction.AuditableRestAction] - Type: [java.lang.Void]
     *
     * @see .isSuppressedEmbeds
     */
    @Nonnull
    @CheckReturnValue
    fun suppressEmbeds(suppressed: Boolean): AuditableRestAction<Void?>?

    /**
     * Attempts to crosspost this message.
     *
     *
     * The following [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] are possible:
     *
     *  * [ALREADY_CROSSPOSTED][net.dv8tion.jda.api.requests.ErrorResponse.ALREADY_CROSSPOSTED]
     * <br></br>The target message has already been crossposted.
     *
     *  * [MISSING_ACCESS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_ACCESS]
     * <br></br>The request was attempted after the account lost access to the
     * [Guild]
     * typically due to being kicked or removed, or after [Permission.VIEW_CHANNEL]
     * was revoked in the [GuildChannel]
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The request was attempted after the account lost
     * [Permission.MESSAGE_MANAGE] in the GuildMessageChannel.
     *
     *  * [UNKNOWN_MESSAGE][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_MESSAGE]
     * <br></br>If the message has already been deleted. This might also be triggered for ephemeral messages.
     *
     *  * [UNKNOWN_CHANNEL][net.dv8tion.jda.api.requests.ErrorResponse.UNKNOWN_CHANNEL]
     * <br></br>The request was attempted after the channel was deleted.
     *
     *
     * @throws IllegalStateException
     *
     *  * If the channel is not a [NewsChannel].
     *  * If the message is ephemeral.
     *
     * @throws MissingAccessException
     * If the currently logged in account does not have [access][Member.hasAccess] in this channel.
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     * If the currently logged in account does not have
     * [Permission.VIEW_CHANNEL] in this channel
     * or if this message is from another user and we don't have [Permission.MESSAGE_MANAGE].
     *
     * @return [RestAction] - Type: [Message]
     *
     * @since  4.2.1
     */
    @Nonnull
    @CheckReturnValue
    fun crosspost(): RestAction<Message?>?

    /**
     * Whether embeds are suppressed for this message.
     * When Embeds are suppressed, they are not displayed on clients nor provided via API until un-suppressed.
     * <br></br>This is a shortcut method for checking if [getFlags()][.getFlags] contains
     * [MessageFlag#EMBEDS_SUPPRESSED][net.dv8tion.jda.api.entities.Message.MessageFlag.EMBEDS_SUPPRESSED]
     *
     * @return Whether or not Embeds are suppressed for this Message.
     *
     * @see .suppressEmbeds
     */
    val isSuppressedEmbeds: Boolean

    @get:Nonnull
    val flags: EnumSet<MessageFlag?>?

    /**
     * Returns the raw message flags of this message
     *
     * @return The raw message flags
     *
     * @see .getFlags
     */
    val flagsRaw: Long

    /**
     * Whether this message is ephemeral.
     * <br></br>The message being ephemeral means it is only visible to the bot and the interacting user
     * <br></br>This is a shortcut method for checking if [.getFlags] contains [MessageFlag.EPHEMERAL]
     *
     * @return Whether the message is ephemeral
     */
    val isEphemeral: Boolean

    /**
     * Whether this message is silent.
     * <br></br>The message being silent means it will not trigger push and desktop notifications
     * <br></br>This is a shortcut method for checking if [.getFlags] contains [MessageFlag.NOTIFICATIONS_SUPPRESSED]
     *
     * @return Whether the message is silent
     */
    @JvmField
    val isSuppressedNotifications: Boolean

    /**
     * Returns a possibly `null` [ThreadChannel] that was started from this message.
     * This can be `null` due to no ThreadChannel being started from it or the ThreadChannel later being deleted.
     *
     * @return The [ThreadChannel] that was started from this message.
     */
    val startedThread: ThreadChannel?

    @JvmField
    @get:Nonnull
    val type: MessageType?

    /**
     * This is sent on the message object when the message is a response to an [Interaction][net.dv8tion.jda.api.interactions.Interaction] without an existing message.
     *
     *
     * This means responses to Message Components do not include this property, instead including a message reference object as components always exist on preexisting messages.
     *
     * @return The [Interaction][net.dv8tion.jda.api.entities.Message.Interaction] of this message.
     */
    val interaction: Interaction?

    /**
     * Creates a new, public [ThreadChannel] spawning/starting at this [Message] inside the [IThreadContainer] this message was sent in.
     * <br></br>The starting message will copy this message, and will be of type [MessageType.THREAD_STARTER_MESSAGE].
     *
     *
     * The resulting [ThreadChannel] may be one of:
     *
     *  * [ChannelType.GUILD_PUBLIC_THREAD]
     *  * [ChannelType.GUILD_NEWS_THREAD]
     *
     *
     *
     * Possible [ErrorResponses][net.dv8tion.jda.api.requests.ErrorResponse] caused by
     * the returned [RestAction][net.dv8tion.jda.api.requests.RestAction] include the following:
     *
     *  * [MISSING_PERMISSIONS][net.dv8tion.jda.api.requests.ErrorResponse.MISSING_PERMISSIONS]
     * <br></br>The channel could not be created due to a permission discrepancy
     *
     *  * [MAX_CHANNELS][net.dv8tion.jda.api.requests.ErrorResponse.MAX_CHANNELS]
     * <br></br>The maximum number of channels were exceeded
     *
     *  * [net.dv8tion.jda.api.requests.ErrorResponse.THREAD_WITH_THIS_MESSAGE_ALREADY_EXISTS]
     * <br></br>This message has already been used to create a thread
     *
     *  * [net.dv8tion.jda.api.requests.ErrorResponse.MAX_ACTIVE_THREADS]
     * <br></br>The maximum number of active threads has been reached, and no more may be created.
     *
     *
     * @param  name
     * The name of the new ThreadChannel (up to {@value Channel#MAX_NAME_LENGTH} characters)
     *
     * @throws IllegalArgumentException
     * If the provided name is null, blank, empty, or longer than {@value Channel#MAX_NAME_LENGTH} characters
     * @throws IllegalStateException
     * If the message's channel is not actually a [net.dv8tion.jda.api.entities.channel.attribute.IThreadContainer].
     * @throws UnsupportedOperationException
     * If this is a forum channel.
     * You must use [createForumPost(...)][net.dv8tion.jda.api.entities.channel.concrete.ForumChannel.createForumPost] instead.
     * @throws InsufficientPermissionException
     * If the bot does not have [Permission.CREATE_PUBLIC_THREADS][net.dv8tion.jda.api.Permission.CREATE_PUBLIC_THREADS] in this channel
     *
     * @return A specific [ThreadChannelAction] that may be used to configure the new ThreadChannel before its creation.
     */
    @CheckReturnValue
    fun createThreadChannel(name: String?): ThreadChannelAction?

    /**
     * Mention constants, useful for use with [Patterns][java.util.regex.Pattern]
     */
    enum class MentionType(
        regex: String,
        /**
         * The Key returned by this method is used to determine the group or parsable mention group they are part of.
         * <br></br>It is used internally in methods like [MessageRequest.setAllowedMentions].
         *
         *
         * Returns `null`, when they don't belong to any mention group.
         *
         * @return Nullable group key for mention parsing
         */
        @JvmField val parseKey: String?
    ) {
        /**
         * Represents a mention for a [User]/[Member][net.dv8tion.jda.api.entities.Member]
         * <br></br>The first and only group matches the id of the mention.
         */
        USER("<@!?(\\d+)>", "users"),

        /**
         * Represents a mention for a [Role][net.dv8tion.jda.api.entities.Role]
         * <br></br>The first and only group matches the id of the mention.
         */
        ROLE("<@&(\\d+)>", "roles"),

        /**
         * Represents a mention for a [GuildChannel]
         * <br></br>The first and only group matches the id of the mention.
         */
        CHANNEL("<#(\\d+)>", null),

        /**
         * Represents a mention for a [CustomEmoji]
         * <br></br>The first group matches the name of the emoji and the second the id of the mention.
         */
        EMOJI("<a?:([a-zA-Z0-9_]+):([0-9]+)>", null),

        /**
         * Represents a mention for all active users, literal `@here`
         */
        HERE("@here", "everyone"),

        /**
         * Represents a mention for all users in a server, literal `@everyone`.
         */
        EVERYONE("@everyone", "everyone"),

        /**
         * Represents a mention for a slash command.
         * <br></br>The first group is the command name, the second group is the subcommand group name (nullable),
         * the third group is the subcommand name (nullable), and the fourth group is the command ID.
         */
        SLASH_COMMAND("</([\\w-]+)(?> ([\\w-]+))??(?> ([\\w-]+))?:(\\d+)>", null);

        @JvmField
        @get:Nonnull
        val pattern: Pattern

        init {
            pattern = Pattern.compile(regex)
        }
    }

    /**
     * Enum representing the flags on a Message.
     *
     *
     * Note: The Values defined in this Enum are not considered final and only represent the current State of *known* Flags.
     */
    enum class MessageFlag(offset: Int) {
        /**
         * The Message has been published to subscribed Channels (via Channel Following)
         */
        CROSSPOSTED(0),

        /**
         * The Message originated from a Message in another Channel (via Channel Following)
         */
        IS_CROSSPOST(1),

        /**
         * Embeds are suppressed on the Message.
         * @see net.dv8tion.jda.api.entities.Message.isSuppressedEmbeds
         */
        EMBEDS_SUPPRESSED(2),

        /**
         * Indicates, that the source message of this crosspost was deleted.
         * This should only be possible in combination with [.IS_CROSSPOST]
         */
        SOURCE_MESSAGE_DELETED(3),

        /**
         * Indicates, that this Message came from the urgent message system
         */
        URGENT(4),

        /**
         * Indicates, that this Message is ephemeral, the Message is only visible to the bot and the interacting user
         * @see Message.isEphemeral
         */
        EPHEMERAL(6),

        /**
         * Indicates, that this Message is an interaction response and the bot is "thinking"
         */
        LOADING(7),

        /**
         * Indicates, that this message will not trigger push and desktop notifications
         * @see Message.isSuppressedNotifications
         */
        NOTIFICATIONS_SUPPRESSED(12),

        /**
         * The Message is a voice message, containing an audio attachment
         */
        IS_VOICE_MESSAGE(13);

        /**
         * Returns the value of the MessageFlag as represented in the bitfield. It is always a power of 2 (single bit)
         *
         * @return Non-Zero bit value of the field
         */
        @JvmField
        val value: Int

        init {
            value = 1 shl offset
        }

        companion object {
            /**
             * Given a bitfield, this function extracts all Enum values according to their bit values and returns
             * an EnumSet containing all matching MessageFlags
             * @param  bitfield
             * Non-Negative integer representing a bitfield of MessageFlags
             * @return Never-Null EnumSet of MessageFlags being found in the bitfield
             */
            @JvmStatic
            @Nonnull
            fun fromBitField(bitfield: Int): EnumSet<MessageFlag> {
                val set = Arrays.stream(entries.toTypedArray())
                    .filter { e: MessageFlag -> e.value and bitfield > 0 }
                    .collect(Collectors.toSet())
                return if (set.isEmpty()) EnumSet.noneOf(MessageFlag::class.java) else EnumSet.copyOf(set)
            }

            /**
             * Converts a Collection of MessageFlags back to the integer representing the bitfield.
             * This is the reverse operation of [.fromBitField].
             * @param  coll
             * A Non-Null Collection of MessageFlags
             * @throws IllegalArgumentException
             * If the provided Collection is `null`
             * @return Integer value of the bitfield representing the given MessageFlags
             */
            fun toBitField(@Nonnull coll: Collection<MessageFlag>): Int {
                Checks.notNull(coll, "Collection")
                var flags = 0
                for (messageFlag in coll) {
                    flags = flags or messageFlag.value
                }
                return flags
            }
        }
    }

    /**
     * Represents a [Message][net.dv8tion.jda.api.entities.Message] file attachment.
     */
    class Attachment(
        private override val id: Long,
        /**
         * The url of the Attachment, most likely on the Discord servers.
         *
         * @return Non-null String containing the Attachment URL.
         */
        @get:Nonnull val url: String,
        /**
         * Url to the resource proxied by the Discord CDN.
         *
         * @return Non-null String containing the proxied Attachment url.
         */
        @get:Nonnull val proxyUrl: String,
        /**
         * The file name of the Attachment when it was first uploaded.
         *
         * @return Non-null String containing the Attachment file name.
         */
        @JvmField @get:Nonnull val fileName: String, private val contentType: String, private val description: String,
        /**
         * The size of the attachment in bytes.
         * <br></br>Example: if `getSize()` returns 1024, then the attachment is 1024 bytes, or 1KiB, in size.
         *
         * @return Positive int containing the size of the Attachment.
         */
        val size: Int,
        /**
         * The height of the Attachment if this Attachment is an image/video.
         * <br></br>If this Attachment is neither an image, nor a video, this returns -1.
         *
         * @return int containing image/video Attachment height, or -1 if attachment is neither image nor video.
         */
        val height: Int,
        /**
         * The width of the Attachment if this Attachment is an image/video.
         * <br></br>If this Attachment is neither an image, nor a video, this returns -1.
         *
         * @return int containing image/video Attachment width, or -1 if attachment is neither image nor video.
         */
        val width: Int,
        /**
         * Whether or not this attachment is from an ephemeral Message.
         * <br></br>If this Attachment is ephemeral, it will automatically be removed after 2 weeks. The attachment is guaranteed to be available as long as the message itself exists.
         *
         * @return True if this attachment is from an ephemeral message
         */
        val isEphemeral: Boolean, private val waveform: String?,
        /**
         * Gets the duration of this attachment. This is currently only nonzero on
         * [voice messages][MessageFlag.IS_VOICE_MESSAGE].
         *
         * @return The duration of this attachment's audio in seconds, or `0`
         * if this is not a voice message.
         */
        val duration: Double, private val jda: JDAImpl
    ) : ISnowflake, AttachedFile {

        @get:Nonnull
        val jDA: JDA
            /**
             * The corresponding JDA instance for this Attachment
             *
             * @return The corresponding JDA instance for this Attachment
             */
            get() = jda

        override fun getIdLong(): Long {
            return id
        }

        @get:Nonnull
        val proxy: AttachmentProxy
            /**
             * Returns an [AttachmentProxy] for this attachment.
             *
             * @return Non-null [AttachmentProxy] of this attachment
             *
             * @see .getProxyUrl
             */
            get() = AttachmentProxy(if (width > 0 && height > 0) proxyUrl else url)
        val fileExtension: String?
            /**
             * The file extension of the Attachment when it was first uploaded.
             * <br></br>Null is returned if no characters follow the last occurrence of the '`.`' character
             * (or if the character is not present in [.getFileName]).
             *
             * @return Non-null String containing the Attachment file extension, or null if it can't be determined.
             */
            get() {
                val index = fileName.lastIndexOf('.') + 1
                return if (index == 0 || index == fileName.length) null else fileName.substring(index)
            }

        /**
         * The Content-Type of this file.
         * <br></br>This is the  [Media type](https://en.wikipedia.org/wiki/Media_type) of the file that would be used in an HTTP request or similar.
         *
         * @return The content-type, or null if this isn't provided
         */
        fun getContentType(): String? {
            return contentType
        }

        /**
         * The description (alt text) of this attachment.
         * <br></br>This description is shown when hovering over the attachment in the client.
         *
         * @return The description, or null if this isn't provided
         */
        fun getDescription(): String? {
            return description
        }

        /**
         * Enqueues a request to retrieve the contents of this Attachment.
         * <br></br>**The receiver is expected to close the retrieved [java.io.InputStream].**
         *
         *
         * **Example**<br></br>
         * <pre>`public void printContents(Message.Attachment attachment)
         * {
         * attachment.retrieveInputStream().thenAccept(in -> {
         * StringBuilder builder = new StringBuilder();
         * byte[] buf = byte[1024];
         * int count = 0;
         * while ((count = in.read(buf)) > 0)
         * {
         * builder.append(new String(buf, 0, count));
         * }
         * in.close();
         * System.out.println(builder);
         * }).exceptionally(t -> { // handle failure
         * t.printStackTrace();
         * return null;
         * });
         * }
        `</pre> *
         *
         * @return [java.util.concurrent.CompletableFuture] - Type: [java.io.InputStream]
         *
         */
        @Nonnull
        @ForRemoval
        @ReplaceWith("getProxy().download()")
        @Deprecated("Replaced by {@link #getProxy}, see {@link AttachmentProxy#download()}")
        fun retrieveInputStream(): CompletableFuture<InputStream> // it is expected that the response is closed by the callback!
        {
            val future = CompletableFuture<InputStream>()
            val req = request
            val httpClient = jDA.httpClient
            httpClient.newCall(req).enqueue(FunctionalCallback
                .onFailure { call: Call?, e: IOException? -> future.completeExceptionally(UncheckedIOException(e)) }
                .onSuccess { call: Call?, response: Response ->
                    if (response.isSuccessful) {
                        val body = IOUtil.getBody(response)
                        if (!future.complete(body)) IOUtil.silentClose(response)
                    } else {
                        future.completeExceptionally(
                            HttpException(
                                response.code().toString() + ": " + response.message()
                            )
                        )
                        IOUtil.silentClose(response)
                    }
                }.build()
            )
            return future
        }

        /**
         * Downloads the attachment into the current working directory using the file name provided by [.getFileName].
         * <br></br>This will download the file using the [callback pool][net.dv8tion.jda.api.JDA.getCallbackPool].
         * Alternatively you can use [.retrieveInputStream] and use a continuation with a different executor.
         *
         *
         * **Example**<br></br>
         * <pre>`public void saveLocally(Message.Attachment attachment)
         * {
         * attachment.downloadToFile()
         * .thenAccept(file -> System.out.println("Saved attachment to " + file.getName()))
         * .exceptionally(t ->
         * { // handle failure
         * t.printStackTrace();
         * return null;
         * });
         * }
        `</pre> *
         *
         * @return [java.util.concurrent.CompletableFuture] - Type: [java.io.File]
         *
         */
        @Nonnull
        @ForRemoval
        @ReplaceWith("getProxy().downloadToFile()")
        @Deprecated("Replaced by {@link #getProxy}, see {@link AttachmentProxy#downloadToFile(File)}")
        fun downloadToFile(): CompletableFuture<File> // using relative path
        {
            return downloadToFile(fileName)
        }

        /**
         * Downloads the attachment to a file at the specified path (relative or absolute).
         * <br></br>This will download the file using the [callback pool][net.dv8tion.jda.api.JDA.getCallbackPool].
         * Alternatively you can use [.retrieveInputStream] and use a continuation with a different executor.
         *
         *
         * **Example**<br></br>
         * <pre>`public void saveLocally(Message.Attachment attachment)
         * {
         * attachment.downloadToFile("/tmp/" + attachment.getFileName())
         * .thenAccept(file -> System.out.println("Saved attachment to " + file.getName()))
         * .exceptionally(t ->
         * { // handle failure
         * t.printStackTrace();
         * return null;
         * });
         * }
        `</pre> *
         *
         * @param  path
         * The path to save the file to
         *
         * @throws java.lang.IllegalArgumentException
         * If the provided path is null
         *
         * @return [java.util.concurrent.CompletableFuture] - Type: [java.io.File]
         *
         */
        @Nonnull
        @ForRemoval
        @ReplaceWith("getProxy().downloadToFile(new File(String))")
        @Deprecated("Replaced by {@link #getProxy}, see {@link AttachmentProxy#downloadToFile(File)}")
        fun downloadToFile(path: String?): CompletableFuture<File> {
            Checks.notNull(path, "Path")
            return downloadToFile(File(path))
        }

        /**
         * Downloads the attachment to a file at the specified path (relative or absolute).
         * <br></br>This will download the file using the [callback pool][net.dv8tion.jda.api.JDA.getCallbackPool].
         * Alternatively you can use [.retrieveInputStream] and use a continuation with a different executor.
         *
         *
         * **Example**<br></br>
         * <pre>`public void saveLocally(Message.Attachment attachment)
         * {
         * attachment.downloadToFile(new File("/tmp/" + attachment.getFileName()))
         * .thenAccept(file -> System.out.println("Saved attachment to " + file.getName()))
         * .exceptionally(t ->
         * { // handle failure
         * t.printStackTrace();
         * return null;
         * });
         * }
        `</pre> *
         *
         * @param  file
         * The file to write to
         *
         * @throws java.lang.IllegalArgumentException
         * If the provided file is null or cannot be written to
         *
         * @return [java.util.concurrent.CompletableFuture] - Type: [java.io.File]
         *
         */
        @Nonnull
        @ForRemoval
        @ReplaceWith("getProxy().downloadToFile(File)")
        @Deprecated("Replaced by {@link #getProxy}, see {@link AttachmentProxy#downloadToFile(File)}")
        fun downloadToFile(file: File): CompletableFuture<File> {
            Checks.notNull(file, "File")
            try {
                if (!file.exists()) file.createNewFile() else Checks.check(
                    file.canWrite(),
                    "Cannot write to file %s",
                    file.getName()
                )
            } catch (e: IOException) {
                throw IllegalArgumentException("Cannot create file", e)
            }
            return retrieveInputStream().thenApplyAsync({ stream: InputStream ->
                try {
                    FileOutputStream(file).use { out ->
                        val buf = ByteArray(1024)
                        var count: Int
                        while (stream.read(buf).also { count = it } > 0) {
                            out.write(buf, 0, count)
                        }
                        return@thenApplyAsync file
                    }
                } catch (e: IOException) {
                    throw UncheckedIOException(e)
                } finally {
                    IOUtil.silentClose(stream)
                }
            }, jDA.callbackPool)
        }

        /**
         * Retrieves the image of this attachment and provides an [net.dv8tion.jda.api.entities.Icon] equivalent.
         * <br></br>Useful with [net.dv8tion.jda.api.managers.AccountManager.setAvatar].
         * <br></br>This will download the file using the [callback pool][net.dv8tion.jda.api.JDA.getCallbackPool].
         * Alternatively you can use [.retrieveInputStream] and use a continuation with a different executor.
         *
         *
         * **Example**<br></br>
         * <pre>`public void changeAvatar(Message.Attachment attachment)
         * {
         * attachment.retrieveAsIcon().thenCompose(icon -> {
         * SelfUser self = attachment.getJDA().getSelfUser();
         * AccountManager manager = self.getManager();
         * return manager.setAvatar(icon).submit();
         * }).exceptionally(t -> {
         * t.printStackTrace();
         * return null;
         * });
         * }
        `</pre> *
         *
         * @throws java.lang.IllegalStateException
         * If this is not an image ([.isImage])
         *
         * @return [java.util.concurrent.CompletableFuture] - Type: [net.dv8tion.jda.api.entities.Icon]
         *
         */
        @Nonnull
        @ReplaceWith("getProxy().downloadAsIcon()")
        @Deprecated("Replaced by {@link #getProxy}, see {@link AttachmentProxy#downloadAsIcon()}")
        fun retrieveAsIcon(): CompletableFuture<Icon> {
            check(isImage) { "Cannot create an Icon out of this attachment. This is not an image." }
            return retrieveInputStream().thenApplyAsync<Icon>({ stream: InputStream? ->
                try {
                    return@thenApplyAsync Icon.Companion.from(stream)
                } catch (e: IOException) {
                    throw UncheckedIOException(e)
                } finally {
                    IOUtil.silentClose(stream)
                }
            }, jDA.callbackPool)
        }

        protected val request: Request
            protected get() = Builder()
                .url(url)
                .addHeader("user-agent", RestConfig.USER_AGENT)
                .addHeader("accept-encoding", "gzip, deflate")
                .build()

        /**
         * Gets the waveform data encoded in this attachment. This is currently only present on
         * [voice messages][MessageFlag.IS_VOICE_MESSAGE].
         *
         * @return A possibly-`null` array of integers representing the amplitude of the
         * audio over time. Amplitude is sampled at 10Hz, but the client will decrease
         * this to keep the waveform to at most 256 bytes.
         * The values in this array are **unsigned**.
         */
        fun getWaveform(): ByteArray? {
            return if (waveform == null) null else Base64.getDecoder().decode(waveform)
        }

        val isImage: Boolean
            /**
             * Whether or not this attachment is an Image,
             * based on [.getWidth], [.getHeight], and [.getFileExtension].
             *
             * @return True if this attachment is an image
             */
            get() {
                if (width < 0) return false //if width is -1, so is height
                val extension = fileExtension
                return extension != null && IMAGE_EXTENSIONS.contains(extension.lowercase(Locale.getDefault()))
            }
        val isVideo: Boolean
            /**
             * Whether or not this attachment is a video,
             * based on [.getWidth], [.getHeight], and [.getFileExtension].
             *
             * @return True if this attachment is a video
             */
            get() {
                if (width < 0) return false //if width is -1, so is height
                val extension = fileExtension
                return extension != null && VIDEO_EXTENSIONS.contains(extension.lowercase(Locale.getDefault()))
            }
        val isSpoiler: Boolean
            /**
             * Whether or not this attachment is marked as spoiler,
             * based on [.getFileName].
             *
             * @return True if this attachment is marked as spoiler
             *
             * @since  4.2.1
             */
            get() = fileName.startsWith("SPOILER_")

        override fun close() {}
        override fun forceClose() {}
        override fun addPart(@Nonnull builder: Builder, index: Int) {}
        @Nonnull
        override fun toAttachmentData(index: Int): DataObject {
            return DataObject.empty().put("id", id)
        }

        companion object {
            private val IMAGE_EXTENSIONS: Set<String> = HashSet(
                mutableListOf(
                    "jpg",
                    "jpeg", "png", "gif", "webp", "tiff", "svg", "apng"
                )
            )
            private val VIDEO_EXTENSIONS: Set<String> = HashSet(
                mutableListOf(
                    "webm",
                    "flv", "vob", "avi", "mov", "wmv", "amv", "mp4", "mpg", "mpeg", "gifv"
                )
            )
        }
    }

    /**
     * Represents an [Interaction][net.dv8tion.jda.api.interactions.Interaction] provided with a [Message][net.dv8tion.jda.api.entities.Message].
     */
    class Interaction(
        private override val id: Long,
        /**
         * The raw interaction type.
         * <br></br>It is recommended to use [.getType] instead.
         *
         * @return The raw interaction type
         */
        val typeRaw: Int,
        /**
         * The command name.
         *
         * @return The command name
         */
        @get:Nonnull val name: String,
        /**
         * The [User] who caused this interaction.
         *
         * @return The [User]
         */
        @get:Nonnull val user: User, private val member: Member
    ) : ISnowflake {

        override fun getIdLong(): Long {
            return id
        }

        /**
         * The [net.dv8tion.jda.api.interactions.InteractionType] for this interaction.
         *
         * @return The [net.dv8tion.jda.api.interactions.InteractionType] or [net.dv8tion.jda.api.interactions.InteractionType.UNKNOWN]
         */
        @Nonnull
        fun getType(): InteractionType {
            return InteractionType.fromKey(typeRaw)
        }

        /**
         * The [Member] who caused this interaction.
         * <br></br>This is null if the interaction is not from a guild.
         *
         * @return The [Member]
         */
        fun getMember(): Member? {
            return member
        }
    }

    companion object {
        /**
         * Suppresses the warning for missing the [MESSAGE_CONTENT][net.dv8tion.jda.api.requests.GatewayIntent.MESSAGE_CONTENT] intent and using one of the dependent getters.
         */
        fun suppressContentIntentWarning() {
            ReceivedMessage.didContentIntentWarning = true
        }

        /** Template for [.getJumpUrl]. */
        const val JUMP_URL = "https://discord.com/channels/%s/%s/%s"

        /**
         * The maximum sendable file size (25 MiB)
         *
         * @see MessageRequest.setFiles
         */
        const val MAX_FILE_SIZE = 25 shl 20

        /**
         * The maximum sendable file size for nitro (50 MiB)
         *
         * @see MessageRequest.setFiles
         */
        @Deprecated("Self-bots are not supported anymore and the value is outdated.")
        val MAX_FILE_SIZE_NITRO = 50 shl 20

        /**
         * The maximum amount of files sendable within a single message ({@value})
         *
         * @see MessageRequest.setFiles
         */
        const val MAX_FILE_AMOUNT = 10

        /**
         * The maximum amount of characters sendable in one message. ({@value})
         * <br></br>This only applies to the raw content and not embeds!
         *
         * @see MessageRequest.setContent
         */
        const val MAX_CONTENT_LENGTH = 2000

        /**
         * The maximum amount of reactions that can be added to one message ({@value})
         *
         * @see Message.addReaction
         */
        const val MAX_REACTIONS = 20

        /**
         * The maximum amount of Embeds that can be added to one message ({@value})
         *
         * @see MessageChannel.sendMessageEmbeds
         * @see MessageRequest.setEmbeds
         */
        const val MAX_EMBED_COUNT = 10

        /**
         * The maximum amount of [Stickers][Sticker] that can be added to a message ({@value})
         *
         * @see GuildMessageChannel.sendStickers
         * @see MessageCreateAction.setStickers
         */
        const val MAX_STICKER_COUNT = 3

        /**
         * The maximum amount of [LayoutComponents][LayoutComponent] that can be added to a message ({@value})
         */
        const val MAX_COMPONENT_COUNT = 5

        /**
         * The maximum character length for a [nonce][.getNonce] ({@value})
         */
        const val MAX_NONCE_LENGTH = 25

        /**
         * Pattern used to find instant invites in strings.
         *
         *
         * The only named group is at index 1 with the name `"code"`.
         *
         * @see .getInvites
         */
        @JvmField
        val INVITE_PATTERN = Pattern.compile(
            "(?:https?://)?" +  // Scheme
                    "(?:\\w+\\.)?" +  // Subdomain
                    "discord(?:(?:app)?\\.com" +  // Discord domain
                    "/invite|\\.gg)/(?<code>[a-z0-9-]+)" +  // Path
                    "(?:\\?\\S*)?(?:#\\S*)?",  // Useless query or URN appendix
            Pattern.CASE_INSENSITIVE
        )

        /**
         * Pattern used to find [Jump URLs][.getJumpUrl] in strings.
         *
         *
         * **Groups**<br></br>
         * <table>
         * <caption style="display: none">Javadoc is stupid, this is not a required tag</caption>
         * <tr>
         * <th>Index</th>
         * <th>Name</th>
         * <th>Description</th>
        </tr> *
         * <tr>
         * <td>0</td>
         * <td>N/A</td>
         * <td>The entire link</td>
        </tr> *
         * <tr>
         * <td>1</td>
         * <td>guild</td>
         * <td>The ID of the target guild</td>
        </tr> *
         * <tr>
         * <td>2</td>
         * <td>channel</td>
         * <td>The ID of the target channel</td>
        </tr> *
         * <tr>
         * <td>3</td>
         * <td>message</td>
         * <td>The ID of the target message</td>
        </tr> *
        </table> *
         * You can use the names with [Matcher.group(String)][java.util.regex.Matcher.group]
         * and the index with [Matcher.group(int)][java.util.regex.Matcher.group].
         *
         * @see .getJumpUrl
         */
        val JUMP_URL_PATTERN = Pattern.compile(
            "(?:https?://)?" +  // Scheme
                    "(?:\\w+\\.)?" +  // Subdomain
                    "discord(?:app)?\\.com" +  // Discord domain
                    "/channels/(?<guild>\\d+)/(?<channel>\\d+)/(?<message>\\d+)" +  // Path
                    "(?:\\?\\S*)?(?:#\\S*)?",  // Useless query or URN appendix
            Pattern.CASE_INSENSITIVE
        )
    }
}
